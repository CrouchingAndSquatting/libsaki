#include "girl_x.h"
#include "lua_var_scope.h"
#include "../table/table.h"



namespace saki
{



GirlX::GirlX(Who who, std::string luaCode)
    : Girl(who, Girl::Id::CUSTOM)
{
    setupLuaGlobal();

    runInGirlEnv(luaCode);
}

GirlX::GirlX(const GirlX &copy)
    : Girl(copy)
{
    // TODO
    // support cloning Lua state to enable skills inside future vision
    // strategy:
    // - Copy everything reachable from the 'girldata' table
    // - Ignore metatables
    //     - Userdata metatables are generated by fixed steps
    // - Ignore coroutines
    // - Deep copy all GC object
    // - Smartize Objects whose lifetime managed by C++
    // - Copy C functions (i.e. pointers), deep copy their upvalues
    // - Copy Lua functions by lua_dump, deep copy their upvalues
    // - Type-switch userdatas, use C++ copy ctor to copy them
    // deep copy should detect cycle

//    setupLuaGlobal();
//    cloneLuaTable(mLua["girldata"], const_cast<GirlX &>(copy).mLua["girldata"]);
}

std::unique_ptr<Girl> GirlX::clone() const
{
    return std::make_unique<GirlX>(*this);
}

void GirlX::onDraw(const Table &table, Mount &mount, Who who, bool rinshan)
{
    sol::object cb = mGirlEnv["ondraw"];
    if (!cb.is<sol::function>())
        return;

    LuaVarScope scope(
        mGirlEnv,
        "game", &table,
        "mount", &mount,
        "who", who,
        "rinshan", rinshan
    );

    (void) scope;

    runInGirlEnv("ondraw()");
    popUpIfAny(table);
}

std::string GirlX::popUpStr() const
{
    std::ostringstream oss;
    oss << "Lua";
    oss << mErrStream.str();
    return oss.str();
}

void GirlX::onTableEvent(const Table &table, const TableEvent &event)
{
    if (event.type() == TableEvent::Type::TABLE_STARTED)
        popUpIfAny(table);
}

void GirlX::setupLuaGlobal()
{
    mLua.open_libraries();

    mLua.script(R"(
        girldata = {}
        girl = {
            math = math,
            table = table,
            string = string,
            pairs = pairs,
            ipairs = ipairs,
            print = function(...)
                local args = table.pack(...)
                for i = 1, args.n do
                    girl.printone(args[i])
                    girl.printone(" ")
                end
                girl.printone("\n")
            end,
            __index = function(t, k)
                return girldata[k]
            end,
            __newindex = function(t, k, v)
                girldata[k] = v
            end
        }
        girl.math.random = nil
        girl.math.randomseed = nil
    )");

    mGirlEnv = mLua["girl"];

    setupLuaClasses();
    mGirlEnv["self"] = mSelf;
    mGirlEnv["printone"] = [this](sol::reference ref) {
        std::string str = mLua["tostring"](ref);
        mErrStream << str;
    };

    mGirlEnv[sol::metatable_key] = mGirlEnv;
}

void GirlX::setupLuaClasses()
{
    setupLuaTile();
    setupLuaWho();
    setupLuaMeld();
    setupLuaMount();
    setupLuaTileCount();
    setupLuaHand();
    setupLuaGame();
}

void GirlX::setupLuaTile()
{
    mGirlEnv.new_enum<Suit>(
        "Suit", {
            { "M", Suit::M },
            { "P", Suit::P },
            { "S", Suit::S },
            { "F", Suit::F },
            { "Y", Suit::Y }
        }
    );

    mGirlEnv.new_usertype<T34>(
        "T34",
        sol::meta_function::construct, sol::factories(
            [this](int ti) {
                if (ti < 0 || ti >= 34) {
                    mLua["error"]("invalid T34 id");
                    return T34();
                }

                return T34(ti);
            },
            [this](Suit s, int v) {
                if (!(1 <= v && v <= 9)) {
                    mLua["error"]("invalid T34 val");
                    return T34();
                }

                return T34(s, v);
            },
            [this](const std::string s) {
                static const std::array<std::string, 34> dict {
                    "1m", "2m", "3m", "4m", "5m", "6m", "7m", "8m", "9m",
                    "1p", "2p", "3p", "4p", "5p", "6p", "7p", "8p", "9p",
                    "1s", "2s", "3s", "4s", "5s", "6s", "7s", "8s", "9s",
                    "1f", "2f", "3f", "4f", "1y", "2y", "3y"
                };

                auto it = std::find(dict.begin(), dict.end(), s);
                if (it == dict.end()) {
                    mLua["error"]("invalid T34 string");
                    return T34();
                }

                return T34(it - dict.begin());
            }
        ),
        "id34", &T34::id34,
        "isyakuhai", &T34::isYakuhai,
        sol::meta_function::to_string, &T34::str,
        "all", sol::var(std::vector<T34>(tiles34::ALL34.begin(), tiles34::ALL34.end()))
    );
}

void GirlX::setupLuaWho()
{
    mGirlEnv.new_usertype<Who>(
        "Who",
        "right", &Who::right,
        "cross", &Who::cross,
        "left", &Who::left,
        sol::meta_function::to_string, &Who::index,
        sol::meta_function::equal_to, &Who::operator==
    );
}

void GirlX::setupLuaMeld()
{
    mGirlEnv.new_usertype<M37>(
        "M37",
        "type", &M37::type,
        sol::meta_function::index, &M37::operator[]
    );

    sol::table m37 = mGirlEnv["M37"];
    m37.new_enum<M37::Type>(
        "Type", {
            { "CHII", M37::Type::CHII },
            { "PON", M37::Type::PON },
            { "DAIMINKAN", M37::Type::DAIMINKAN },
            { "ANKAN", M37::Type::ANKAN },
            { "KAKAN", M37::Type::KAKAN }
        }
    );
}

void GirlX::setupLuaMount()
{
    mGirlEnv.new_usertype<Mount>(
        "Mount",
        "lighta", sol::overload(
            [](Mount &mount, T34 t, int mk, bool rin) {
                mount.lightA(t, mk, rin);
            },
            [](Mount &mount, T34 t, int mk) {
                mount.lightA(t, mk);
            }
        )
    );
}

void GirlX::setupLuaTileCount()
{
    mGirlEnv.new_usertype<TileCount>(
        "Tilecount",
        "ct", sol::overload(
            [](const TileCount &tc, T34 t) {
                return tc.ct(t);
            },
            [](const TileCount &tc, Suit s) {
                return tc.ct(s);
            }
        )
    );
}

void GirlX::setupLuaHand()
{
    mGirlEnv.new_usertype<Hand>(
        "Hand",
        "closed", &Hand::closed,
        "ct", &Hand::ct,
        "ready", &Hand::ready,
        "step", &Hand::step,
        "step4", &Hand::step4,
        "step7", &Hand::step7,
        "step13", &Hand::step13,
        "effa", &Hand::effA,
        "effa4", &Hand::effA4,
        "ismenzen", &Hand::isMenzen,
        "barks", &Hand::barks
    );
}

void GirlX::setupLuaGame()
{
    mGirlEnv.new_usertype<Table>(
        "Game",
        "gethand", &Table::getHand,
        "getround", &Table::getRound,
        "getextraround", &Table::getExtraRound,
        "getdealer", &Table::getDealer,
        "getselfwind", &Table::getSelfWind,
        "getroundwind", &Table::getRoundWind
    );
}

void GirlX::addError(const char *what)
{
    mErrStream << what << '\n';
}

void GirlX::runInGirlEnv(const std::string_view &code)
{
    try {
        mLua.safe_script(code, mGirlEnv);
    } catch (const sol::error &e) {
        addError(e.what());
    }
}

void GirlX::popUpIfAny(const Table &table)
{
    if (mErrStream.tellp() > 0) {
        table.popUp(mSelf);
        mErrStream.str("");
    }
}



} // namespace saki
