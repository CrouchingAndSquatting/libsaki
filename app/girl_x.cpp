#include "girl_x.h"
#include "../table/table.h"

#include <unordered_map>



namespace saki
{



using CloneCache = std::unordered_map<const void *, kaguya::LuaRef>;

void cloneLuaTable(kaguya::LuaTable lhs, kaguya::LuaTable rhs, CloneCache &cache);

template<typename Key>
void cloneLuaTableValue(kaguya::LuaTable lhs, kaguya::LuaTable rhs, Key key, CloneCache &cache)
{
    kaguya::LuaRef valRef = rhs[key];
    if (valRef.type() == LUA_TTABLE) {
        const void *valPtr = valRef.native_pointer();
        auto it = cache.find(valPtr);
        if (it == cache.end()) {
            // creat new node
            lhs[key] = kaguya::NewTable();
            cache[valPtr] = lhs[key];

            // deep copy
            cloneLuaTable(lhs[key], valRef, cache);
        } else {
            // link existing node
            kaguya::LuaRef ref = it->second;
            lhs[key] = ref;
        }
    } else if (valRef.type() == LUA_TUSERDATA) {
        kaguya::LuaUserData data = valRef;
        std::string name = data.getMetatable().getRawField("__name");
        if (name == kaguya::metatableName<T34>()) {
            T34 t = data;
            lhs[key] = t;
        } else {
            // TODO other userdata types
        }
        // TODO also cache userdata refs
    } else if (valRef.type() == LUA_TFUNCTION) {
        kaguya::LuaFunction func = valRef;
        // TODO copy pointers for C functions, copy dump for Lua functions
        // TODO copy upvalues
    } else if (valRef.type() == LUA_TBOOLEAN
               || valRef.type() == LUA_TNUMBER
               || valRef.type() == LUA_TSTRING) {
        // scalar
        lhs[key] = rhs[key];
    } else {
        // cannot handle light userdata and thread
        util::p("fucking type", valRef.type());
    }
}

void cloneLuaTable(kaguya::LuaTable lhs, kaguya::LuaTable rhs, CloneCache &cache)
{
    for (kaguya::LuaRef keyRef : rhs.keys()) {
        auto type = keyRef.type();
        if (type == LUA_TSTRING) {
            std::string key = keyRef;
            cloneLuaTableValue(lhs, rhs, key, cache);
        } else if (type == LUA_TNUMBER) {
            int key = keyRef; // TODO float?
            cloneLuaTableValue(lhs, rhs, key, cache);
        } else {
            util::p("fucking key type", type);
            // TODO deal with other key types
        }
    }
}

///
/// \brief Deep-copy a Lua table
///
/// Note that Lua table is a graph, not tree
/// We use DFS with cycle handling
///
void cloneLuaTable(kaguya::LuaTable lhs, kaguya::LuaTable rhs)
{
    // TODO add cache[rhs] = lhs
    CloneCache cache;
    cloneLuaTable(lhs, rhs, cache);
}



GirlX::GirlX(Who who, std::string luaCode)
    : Girl(who, Girl::Id::CUSTOM)
{
    setupLuaGlobal();

    mLua.dostring(luaCode, mLua["girl"]);
}

GirlX::GirlX(const GirlX &copy)
    : Girl(copy)
{
    // TODO
    // support cloning Lua state to enable skills inside future vision
    // strategy:
    // - Copy everything reachable from the 'girldata' table
    // - Ignore metatables
    //     - Userdata metatables are generated by fixed steps
    // - Ignore coroutines
    // - Deep copy all GC object
    // - Smartize Objects whose lifetime managed by C++
    // - Copy C functions (i.e. pointers), deep copy their upvalues
    // - Copy Lua functions by lua_dump, deep copy their upvalues
    // - Type-switch userdatas, use C++ copy ctor to copy them

//    setupLuaGlobal();
//    cloneLuaTable(mLua["girldata"], const_cast<GirlX &>(copy).mLua["girldata"]);
}

std::unique_ptr<Girl> GirlX::clone() const
{
    return std::make_unique<GirlX>(*this);
}

void GirlX::onDraw(const Table &table, Mount &mount, Who who, bool rinshan)
{
    kaguya::LuaTable girl = mLua["girl"];

    girl.setRawField("game", &table);
    girl.setRawField("mount", &mount);
    girl.setRawField("who", who);
    girl.setRawField("rinshan", rinshan);

    mLua.dostring("if ondraw then ondraw() end", girl);

    girl.setRawField("game", nullptr);
    girl.setRawField("mount", nullptr);

    popUpIfAny(table);
}

std::string GirlX::popUpStr() const
{
    std::ostringstream oss;
    oss << "Lua";
    oss << mErrStream.str();
    return oss.str();
}

void GirlX::onTableEvent(const Table &table, const TableEvent &event)
{
    if (event.type() == TableEvent::Type::TABLE_STARTED)
        popUpIfAny(table);
}

void GirlX::setupLuaGlobal()
{
    mLua.setErrorHandler([this](int errcode, const char *str) {
        (void) errcode;
        addError(str);
    });

    mLua.dostring(R"(
        girldata = {}
        girl = {
            math = math,
            table = table,
            string = string,
            pairs = pairs,
            ipairs = ipairs,
            print = function(...)
                for _, v in ipairs({...}) do
                    girl.printone(v)
                    girl.printone(" ")
                end
                girl.printone("\n")
            end,
            __index = function(t, k)
                return girldata[k]
            end,
            __newindex = function(t, k, v)
                girldata[k] = v
            end
        }
    )");

    kaguya::LuaTable girl = mLua["girl"];
    setupLuaClasses(girl);
    girl["self"] = mSelf; // TODO make readonly
    girl["printone"] = kaguya::function([this](kaguya::LuaRef ref) {
        mErrStream << static_cast<const char *>(mLua["tostring"](ref));
    });

    girl.setMetatable(girl);
}

void GirlX::setupLuaClasses(kaguya::LuaTable girl)
{
    setupLuaTile(girl);
    setupLuaWho(girl);
    setupLuaMount(girl);
    setupLuaTileCount(girl);
    setupLuaHand(girl);
    setupLuaGame(girl);
}

void GirlX::setupLuaWho(kaguya::LuaTable girl)
{
    auto who = kaguya::UserdataMetatable<Who>();
    who.addStaticFunction("__eq", [](Who a, Who b) { return a == b; });
    who.addFunction("__tostring", &Who::index);
    who.addFunction("right", &Who::right);
    who.addFunction("cross", &Who::cross);
    who.addFunction("left", &Who::left);
    girl["Who"].setClass(who);
}

void GirlX::setupLuaTile(kaguya::LuaTable girl)
{
    auto t34 = kaguya::UserdataMetatable<T34>();
    t34.setConstructors<T34(int)>();
    t34.addFunction("id34", &T34::id34);
    t34.addFunction("__tostring", &T34::str);
    t34.addStaticField("all", std::vector<T34>(tiles34::ALL34.begin(), tiles34::ALL34.end()));
    girl["T34"].setClass(t34);
}

void GirlX::setupLuaMount(kaguya::LuaTable girl)
{
    auto mount = kaguya::UserdataMetatable<Mount>();
    mount.addStaticFunction("lighta", [](Mount *mount, T34 t, int mk) {
        mount->lightA(t, mk, false);
    });
    girl["Mount"].setClass(mount);
}

void GirlX::setupLuaTileCount(kaguya::LuaTable girl)
{
    auto tc = kaguya::UserdataMetatable<TileCount>();
    tc.addStaticFunction("ct", [](const TileCount *count, kaguya::LuaRef arg){
        if (arg.type() == LUA_TUSERDATA) {
            kaguya::LuaUserData data = arg;
            std::string name = data.getMetatable().getRawField("__name");
            if (name == kaguya::metatableName<T34>()) {
                T34 t = data;
                return count->ct(t);
            }
        }

        util::p("fucking arg");
        return 0;
    });
    girl["Tilecount"].setClass(tc);
}

void GirlX::setupLuaHand(kaguya::LuaTable girl)
{
    auto hand = kaguya::UserdataMetatable<Hand>();
    hand.addFunction("closed", &Hand::closed);
    hand.addFunction("ct", &Hand::ct);
    hand.addFunction("ready", &Hand::ready);
    hand.addFunction("step4", &Hand::step4);
    hand.addFunction("step7", &Hand::step7);
    hand.addFunction("step13", &Hand::step13);
    hand.addStaticFunction("effa", [](const Hand *hand) {
        auto res = hand->effA();
        return std::vector<T34>(res.begin(), res.end());
    });
    hand.addStaticFunction("effa4", [](const Hand *hand) {
        auto res = hand->effA4();
        return std::vector<T34>(res.begin(), res.end());
    });
    girl["Hand"].setClass(hand);
}

void GirlX::setupLuaGame(kaguya::LuaTable girl)
{
    auto game = kaguya::UserdataMetatable<Table>();
    game.addFunction("gethand", &Table::getHand);
    game.addFunction("getround", &Table::getRound);
    game.addFunction("getextraround", &Table::getExtraRound);
    game.addFunction("getdealer", &Table::getDealer);
    girl["Game"].setClass(game);
}

void GirlX::addError(const char *what)
{
    mErrStream << what << '\n';
}

void GirlX::popUpIfAny(const Table &table)
{
    if (mErrStream.tellp() > 0) {
        table.popUp(mSelf);
        mErrStream.str("");
    }
}



} // namespace saki
